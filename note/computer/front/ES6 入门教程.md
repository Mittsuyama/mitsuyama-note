# ES6 入门教程

> 阮一峰：《ES6 入门教程》 原文链接

## let 和 const 命令

1. `var` 导致「变量提升」
2. `let` 和 `const` 的**暂时性死区**：`typeof` 不安全
3. 不允许重复声明
4. ES5 只有函数作用域和全局作用域，ES6 的块级作用域（必须有大括号，可以声明函数）
5. 注意 `const` 指向复合型数据类型
6. 顶层对象：`window, self, global, globalThis`

## 变量的解构赋值

1. 对象解构的简写与原本写法（ `{ A: B }` 谁是匹配模式，谁是变量）
2. 默认值（严格等于 `undefined`）
3. 解构赋值中存在的暂时性死区
4. 数组作为对象的解构
5. JavaScript 会把行首是大括号的语句解释为代码块，用已经声明过的变量用于解构赋值要注意。
6. 解构赋值右边不是对象的情况
7. 模式中的圆括号
8. 遍历 `Map`

## 字符串的扩展

1. Unicode 表示法：`\\, \\x, \\u, \\u{}`
2. 对 Unicode 正确的 `for...of`
3. 模板字符串

## 正则的扩展

1. RegExp 构造函数的参数（ES6 中 1 可以为正则表达式）
2. u 修饰符：点字符，Unicode 字符表示法，准确的量词，预定义模式，i 修饰符，为定义转义无效
3. y 修饰符：粘连
4. s 修饰符：dotAll 模式
5. 先行断言，先行否定断言，ES2018 引入后行断言
6. Unicode 属性类 `\\p \\P`
7. 具名组匹配 `(?<name>)`：`matchObj.groups.name`，解构赋值，引用（`\\k<name>)`，索引

## 数值的扩展

1. 八进制 `0o`
2. `Number.isFinite()`, `Number.isNaN`，与传统的区别（非 `Number` 一律返回 `false`）
3. `Number.EPSILON()`
4. `Number.isSafeInteger()`

函数的扩展：

1. 新增默认值，以及与解构赋值结合使用，注意以下函数参数的区别：
    1. `function f1({x = 0, y = 0} = {}) {}`
    2. `function f2({x, y} = { x: 0, y: 0 }) {}`
2. 默认参数放末尾
3. 设置默认值引起的作用域，以及暂时性死区
4. 利用默认参数指定某个参数不能省略
5. `rest` 参数：`...variable`，与 `arguments` 的区别
6. 严格模式（参数使用默认值，解构赋值，扩展运算符时，禁止严格模式）
7. 箭头函数
    1. `this`：定义所在的对象，不是使用时的对象；不能使用 `new`；不能使用 `arguments`；不能使用 `yield`
    2. 不适用：定义对象的方法（对象不构成单独的作用域）；需要动态的 `this`
    3. 适用于 lambda 表达式
8. 尾调用优化（只在严格模式下开启）、尾递归

## 数组的扩展

1. 扩展运算符：函数调用（替代 apply 方法）；克隆数组；合并数组（浅拷贝）；与解构赋值结合，取原数组的一部分
2. 将字符串转数组（正确识别四字节 Unicode 码，从而判断长度）
3. 只要是实现了 Iterator 接口的对象都能用扩展运算符
4. 数组的空位
    1. 空位不是 `undefined`，而是没有任何值
    2. ES5 对空位的处理不一致
    3. ES6 明确将空位转为 `undefined`

## 对象的扩展

1. 属性的简介表示法
2. 属性名表达式

## proxy

拦截外界的访问并进行重写，ES6 原生提供 Proxy 构造函数，`var proxy = new Proxy(target, handler);`